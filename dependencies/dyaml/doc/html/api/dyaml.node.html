<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>dyaml.node - D:YAML 0.4 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<img id="logo" alt="D:YAML logo" src="images/logo.png"><a id="main-heading" href="index.html">D:YAML 0.4 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul><li><a href="../index.html">Documentation home</a></li>
</ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="dyaml.constructor.html">dyaml.constructor</a></li>
<li><a href="dyaml.dumper.html">dyaml.dumper</a></li>
<li><a href="dyaml.encoding.html">dyaml.encoding</a></li>
<li><a href="dyaml.exception.html">dyaml.exception</a></li>
<li><a href="dyaml.linebreak.html">dyaml.linebreak</a></li>
<li><a href="dyaml.loader.html">dyaml.loader</a></li>
<li><a href="dyaml.node.html">dyaml.node</a></li>
<li><a href="dyaml.representer.html">dyaml.representer</a></li>
<li><a href="dyaml.resolver.html">dyaml.resolver</a></li>
<li><a href="dyaml.style.html">dyaml.style</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>dyaml.node</h1>
<!-- Generated by Ddoc from dyaml/node.d -->
<p>Node of a YAML document. Used to read YAML data once it's loaded,
 and to prepare data to emit.</p>

<dl><dt class="d_decl">class <a name="NodeException"></a><span class="ddoc_psymbol">NodeException</span>: dyaml.exception.YAMLException;
</dt>
<dd><p>Exception thrown at node related errors.</p>

</dd>
<dt class="d_decl">struct <a name="YAMLNull"></a><span class="ddoc_psymbol">YAMLNull</span>;
</dt>
<dd><p>Null YAML type. Used in nodes with null values.</p>

<dl><dt class="d_decl">const string <a name="toString"></a><span class="ddoc_psymbol">toString</span>();
</dt>
<dd><p>Used for string conversion.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="Node"></a><span class="ddoc_psymbol">Node</span>;
</dt>
<dd><p>YAML node.
</p>
<p>This is a pseudo-dynamic type that can store any YAML value, including a
 sequence or mapping of nodes. You can get data from a <a name="Node"></a><span class="ddoc_psymbol">Node</span> directly or
 iterate over it if it's a collection.</p>

<dl><dt class="d_decl">struct <a name="Pair"></a><span class="ddoc_psymbol">Pair</span>;
</dt>
<dd><p>Key-value pair of YAML nodes, used in mappings.</p>

<dl><dt class="d_decl">Node <a name="key"></a><span class="ddoc_psymbol">key</span>;
</dt>
<dd><p>Key node.</p>

</dd>
<dt class="d_decl">Node <a name="value"></a><span class="ddoc_psymbol">value</span>;
</dt>
<dd><p>Value node.</p>

</dd>
<dt class="d_decl">this(K, V)(K <b>key</b>, V <b>value</b>);
</dt>
<dd><p>Construct a Pair from two values. Will be converted to Nodes if needed.</p>

</dd>
<dt class="d_decl">const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(ref const Pair <b>rhs</b>);
</dt>
<dd><p>Equality test with another Pair.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">this(T)(T <b>value</b>, in string <b>tag</b> = null);
</dt>
<dd><p>Construct a Node from a value.
</p>
<p>Any type except of Node can be stored in a Node, but default YAML
 types (integers, floats, strings, timestamps, etc.) will be stored
 more efficiently.
<br>

<br>

 Note that to emit any non-default types you store
 in a node, you need a Representer to represent them in YAML -
 otherwise emitting will fail.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>value</td>
<td valign=top>Value to store in the node.</td></tr>
<tr><td valign=top>tag</td>
<td valign=top>Overrides tag of the node when emitted, regardless
                  of tag determined by Representer. Representer uses
                  this to determine YAML data type when a D data type
                  maps to multiple different YAML data types. Tag must
                  be in full form, e.g. "tag:yaml.org,2002:int", not
                  a shortcut, like "!!int".</td></tr>
</table></div>

</dd>
<dt class="d_decl">this(T)(T[] <b>array</b>, in string <b>tag</b> = null);
</dt>
<dd><p>Construct a node from an array.
</p>
<p>If array is an array of nodes or pairs, it is stored directly.
 Otherwise, every value in the array is converted to a node, and
 those nodes are stored.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>array</td>
<td valign=top>Values to store in the node.</td></tr>
<tr><td valign=top>tag</td>
<td valign=top>Overrides tag of the node when emitted, regardless
                  of tag determined by Representer. Representer uses
                  this to determine YAML data type when a D data type
                  maps to multiple different YAML data types.
                  This is used to differentiate between YAML sequences
                  ("!!seq") and sets ("!!set"), which both are
                  internally represented as an array_ of nodes. Tag
                  must be in full form, e.g. "tag:yaml.org,2002:set",
                  not a shortcut, like "!!set".</td></tr>
</table></div>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//Will be emitted as a sequence (default for arrays)
</span> <span class="d_keyword">auto</span> seq = Node([1, 2, 3, 4, 5]);
 <span class="d_comment">//Will be emitted as a set (overriden tag)
</span> <span class="d_keyword">auto</span> set = Node([1, 2, 3, 4, 5], <span class="d_string">"tag:yaml.org,2002:set"</span>);
</pre>
</div>

</dd>
<dt class="d_decl">this(K, V)(V[K] <b>array</b>, in string <b>tag</b> = null);
</dt>
<dd><p>Construct a node from an associative array.
</p>
<p>If keys and/or values of array are nodes, they stored directly.
 Otherwise they are converted to nodes and then stored.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>array</td>
<td valign=top>Values to store in the node.</td></tr>
<tr><td valign=top>tag</td>
<td valign=top>Overrides tag of the node when emitted, regardless
                  of tag determined by Representer. Representer uses
                  this to determine YAML data type when a D data type
                  maps to multiple different YAML data types.
                  This is used to differentiate between YAML unordered
                  mappings ("!!map"), ordered mappings ("!!omap"), and
                  pairs ("!!pairs") which are all internally
                  represented as an array of node pairs. Tag must be
                  in full form, e.g. "tag:yaml.org,2002:omap", not a
                  shortcut, like "!!omap".</td></tr>
</table></div>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//Will be emitted as an unordered mapping (default for mappings)
</span> <span class="d_keyword">auto</span> map   = Node([1 : <span class="d_string">"a"</span>, 2 : <span class="d_string">"b"</span>]);
 <span class="d_comment">//Will be emitted as an ordered map (overriden tag)
</span> <span class="d_keyword">auto</span> omap  = Node([1 : <span class="d_string">"a"</span>, 2 : <span class="d_string">"b"</span>], <span class="d_string">"tag:yaml.org,2002:omap"</span>);
 <span class="d_comment">//Will be emitted as pairs (overriden tag)
</span> <span class="d_keyword">auto</span> pairs = Node([1 : <span class="d_string">"a"</span>, 2 : <span class="d_string">"b"</span>], <span class="d_string">"tag:yaml.org,2002:pairs"</span>);
</pre>
</div>

</dd>
<dt class="d_decl">this(K, V)(K[] <b>keys</b>, V[] <b>values</b>, in string <b>tag</b> = null);
</dt>
<dd><p>Construct a node from arrays of keys and values.
</p>
<p>Constructs a mapping node with key-value pairs from
 keys and values, keeping their order. Useful when order
 is important (ordered maps, pairs).
<br>

<br>

 keys and values must have equal length.
<br>

<br>

 If keys and/or values are nodes, they are stored directly/
 Otherwise they are converted to nodes and then stored.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>keys</td>
<td valign=top>Keys of the mapping, from first to last pair.</td></tr>
<tr><td valign=top>values</td>
<td valign=top>Values of the mapping, from first to last pair.</td></tr>
<tr><td valign=top>tag</td>
<td valign=top>Overrides tag of the node when emitted, regardless
                   of tag determined by Representer. Representer uses
                   this to determine YAML data type when a D data type
                   maps to multiple different YAML data types.
                   This is used to differentiate between YAML unordered
                   mappings ("!!map"), ordered mappings ("!!omap"), and
                   pairs ("!!pairs") which are all internally
                   represented as an array of node pairs. Tag must be
                   in full form, e.g. "tag:yaml.org,2002:omap", not a
                   shortcut, like "!!omap".</td></tr>
</table></div>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//Will be emitted as an unordered mapping (default for mappings)
</span> <span class="d_keyword">auto</span> map   = Node([1, 2], [<span class="d_string">"a"</span>, <span class="d_string">"b"</span>]);
 <span class="d_comment">//Will be emitted as an ordered map (overriden tag)
</span> <span class="d_keyword">auto</span> omap  = Node([1, 2], [<span class="d_string">"a"</span>, <span class="d_string">"b"</span>], <span class="d_string">"tag:yaml.org,2002:omap"</span>);
 <span class="d_comment">//Will be emitted as pairs (overriden tag)
</span> <span class="d_keyword">auto</span> pairs = Node([1, 2], [<span class="d_string">"a"</span>, <span class="d_string">"b"</span>], <span class="d_string">"tag:yaml.org,2002:pairs"</span>);
</pre>
</div>

</dd>
<dt class="d_decl">const @property bool <a name="isValid"></a><span class="ddoc_psymbol">isValid</span>();
</dt>
<dd><p>Is this node valid (initialized)? </p>

</dd>
<dt class="d_decl">const @property bool <a name="isScalar"></a><span class="ddoc_psymbol">isScalar</span>();
</dt>
<dd><p>Is this node a scalar value?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isSequence"></a><span class="ddoc_psymbol">isSequence</span>();
</dt>
<dd><p>Is this node a sequence?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isMapping"></a><span class="ddoc_psymbol">isMapping</span>();
</dt>
<dd><p>Is this node a mapping?</p>

</dd>
<dt class="d_decl">const @property bool <a name="isUserType"></a><span class="ddoc_psymbol">isUserType</span>();
</dt>
<dd><p>Is this node a user defined type?</p>

</dd>
<dt class="d_decl">const @property string <a name="tag"></a><span class="ddoc_psymbol">tag</span>();
</dt>
<dd><p>Return <a name="tag"></a><span class="ddoc_psymbol">tag</span> of the node.</p>

</dd>
<dt class="d_decl">const bool <a name="opEquals"></a><span class="ddoc_psymbol">opEquals</span>(T)(ref const T <b>rhs</b>);
</dt>
<dd><p>Equality test.
</p>
<p>If T is Node, recursively compare all subnodes.
 This might be quite expensive if testing entire documents.
<br>

 If T is not Node, convert the node to T and test equality with that.

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_keyword">auto</span> node = Node(42);

 <span class="d_keyword">assert</span>(node == 42);
 <span class="d_keyword">assert</span>(node == <span class="d_string">"42"</span>);
 <span class="d_keyword">assert</span>(node != <span class="d_string">"43"</span>);
</pre>

</div>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>rhs</td>
<td valign=top>Variable to test equality with.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr"><b>true</b> if equal, <b>false</b> otherwise.</div>

</dd>
<dt class="d_decl">alias <a name="as"></a><span class="ddoc_psymbol">as</span>;
</dt>
<dd><p>Shortcut for get().</p>

</dd>
<dt class="d_decl">T <a name="get"></a><span class="ddoc_psymbol">get</span>(T)();
</dt>
<dd><p>Get the value of the node as specified type.
</p>
<p>If the specifed type does not match type in the node,
 conversion is attempted.
<br>

 Numeric values are range checked, throwing if out of range of
 requested type.
<br>

 Timestamps are stored as std.datetime.SysTime.
 Binary values are decoded and stored as ubyte[].
<br>

 <br><b>Mapping default values:</b>
<br>

 <div class="pbr">The '=' key can be used to denote the default value of a mapping.
 This can be used when a node is scalar in early versions of a program,
 but is replaced by a mapping later. Even if the node is a mapping, the
 <a name="get"></a><span class="ddoc_psymbol">get</span> method can be used as if it was a scalar if it has a default value.
 This way, new YAML files where the node is a mapping can still be read
 by old versions of the program, which expect the node to be a scalar.
 </div>

</p>
<b>Examples:</b><div class="pbr">Automatic type conversion:
<pre class="d_code"> <span class="d_keyword">auto</span> node = Node(42);

 <span class="d_keyword">assert</span>(node.as!<span class="d_keyword">int</span> == 42);
 <span class="d_keyword">assert</span>(node.as!string == <span class="d_string">"42"</span>);
 <span class="d_keyword">assert</span>(node.as!<span class="d_keyword">double</span> == 42.0);
</pre>

</div>
<b>Returns:</b><div class="pbr">Value of the node as specified type.

</div>
<b>Throws:</b><div class="pbr">NodeException if unable to convert to specified type, or if
          the value is out of range of requested type.</div>

</dd>
<dt class="d_decl">const @property size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><p>If this is a collection, return its length.
</p>
<p>Otherwise, throw NodeException.

</p>
<b>Returns:</b><div class="pbr">Number of elements in a sequence or key-value pairs in a mapping.

</div>
<b>Throws:</b><div class="pbr">NodeException if this is not a sequence nor a mapping.</div>

</dd>
<dt class="d_decl">Node <a name="opIndex"></a><span class="ddoc_psymbol">opIndex</span>(T)(T <b>index</b>);
</dt>
<dd><p>Get the element at specified index.
</p>
<p>If the node is a sequence, index must be integral.
<br>

<br>

 If the node is a mapping, return the value corresponding to the first
 key equal to index, even after conversion. I.e; node["12"] will
 return value of the first key that equals "12", even if it's an integer.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>index</td>
<td valign=top>Index to use.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Value corresponding to the index.

</div>
<b>Throws:</b><div class="pbr">NodeException if the index could not be found,
          non-integral index is used with a sequence or the node is
          not a collection.</div>

</dd>
<dt class="d_decl">void <a name="opIndexAssign"></a><span class="ddoc_psymbol">opIndexAssign</span>(K, V)(V <b>value</b>, K <b>index</b>);
</dt>
<dd><p>Set element at specified index in a collection.
</p>
<p>This method can only be called on collection nodes.
<br>

 If the node is a sequence, index must be integral.
<br>

 If the node is a mapping, sets the value corresponding to the first
 key matching index (including conversion, so e.g. "42" matches 42).
<br>

 If the node is a mapping and no key matches index, a new key-value
 pair is added to the mapping. In sequences the index must be in
 range. This ensures behavior siilar to D arrays and associative
 arrays.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>index</td>
<td valign=top>Index of the value to set.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr">NodeException if the node is not a collection, index is out
          of range or if a non-integral index is used on a sequence node.</div>

</dd>
<dt class="d_decl">int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(T)(int delegate(ref T) <b>dg</b>);
</dt>
<dd><p>Foreach over a sequence, getting each element as T.
</p>
<p>If T is Node, simply iterate over the nodes in the sequence.
 Otherwise, convert each node to T during iteration.

</p>
<b>Throws:</b><div class="pbr">NodeException if the node is not a sequence or an
          element could not be converted to specified type.</div>

</dd>
<dt class="d_decl">int <a name="opApply"></a><span class="ddoc_psymbol">opApply</span>(K, V)(int delegate(ref K, ref V) <b>dg</b>);
</dt>
<dd><p>Foreach over a mapping, getting each key/value as K/V.
</p>
<p>If the K and/or V is Node, simply iterate over the nodes in the mapping.
 Otherwise, convert each key/value to T during iteration.

</p>
<b>Throws:</b><div class="pbr">NodeException if the node is not a mapping or an
          element could not be converted to specified type.</div>

</dd>
<dt class="d_decl">void <a name="add"></a><span class="ddoc_psymbol">add</span>(T)(T <b>value</b>);
</dt>
<dd><p>Add an element to a sequence.
</p>
<p>This method can only be called on sequence nodes.
<br>

 If value is a node, it is copied to the sequence directly. Otherwise
 value is converted to a node and then stored in the sequence.
<br>

 <p>When emitting, all values in the sequence will be emitted. When
 using the !!set tag, the user needs to ensure that all elements in
 the sequence are unique, otherwise <b>invalid</b> YAML code will be
 emitted.</p>

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>value</td>
<td valign=top>Value to add to the sequence.</td></tr>
</table></div>

</dd>
<dt class="d_decl">void <a name="add"></a><span class="ddoc_psymbol">add</span>(K, V)(K <b>key</b>, V <b>value</b>);
</dt>
<dd><p>Add a key-value pair to a mapping.
</p>
<p>This method can only be called on mapping nodes.
<br>

 If key and/or value is a node, it is copied to the mapping directly.
 Otherwise it is converted to a node and then stored in the mapping.
<br>

 <p>It is possible for the same key to be present more than once in a
 mapping. When emitting, all key-value pairs will be emitted.
 This is useful with the "!!pairs" tag, but will result in
 <b>invalid</b> YAML with "!!map" and "!!omap" tags.</p>

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>key</td>
<td valign=top>Key to add.</td></tr>
<tr><td valign=top>value</td>
<td valign=top>Value to add.</td></tr>
</table></div>

</dd>
<dt class="d_decl">void <a name="remove"></a><span class="ddoc_psymbol">remove</span>(T)(T <b>value</b>);
</dt>
<dd><p>Remove first (if any) occurence of a value in a collection.
</p>
<p>This method can only be called on collection nodes.
<br>

 If the node is a sequence, the first node matching value (including
 conversion, so e.g. "42" matches 42) is removed.
 If the node is a mapping, the first key-value pair where value
 matches specified value is removed.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>value</td>
<td valign=top>Value to remove.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr">NodeException if the node is not a collection.</div>

</dd>
<dt class="d_decl">void <a name="removeAt"></a><span class="ddoc_psymbol">removeAt</span>(T)(T <b>index</b>);
</dt>
<dd><p>Remove element at the specified index of a collection.
</p>
<p>This method can only be called on collection nodes.
<br>

 If the node is a sequence, index must be integral.
<br>

 If the node is a mapping, remove the first key-value pair where
 key matches index (including conversion, so e.g. "42" matches 42).
<br>

 If the node is a mapping and no key matches index, nothing is removed
 and no exception is thrown. This ensures behavior siilar to D arrays
 and associative arrays.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>index</td>
<td valign=top>Index to remove at.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr">NodeException if the node is not a collection, index is out
          of range or if a non-integral index is used on a sequence node.</div>

</dd>
<dt class="d_decl">const const int <a name="opCmp"></a><span class="ddoc_psymbol">opCmp</span>(ref const Node <b>node</b>);
</dt>
<dd><p>Compare with another node.</p>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2011. Based on <a href="http://www.pyyaml.org">PyYAML</a> by Kirill Simonov. |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
