<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>dgamevfs.vfs - D:GameVFS 0.1 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<a id="main-heading" href="index.html">D:GameVFS 0.1 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul></ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="dgamevfs.exceptions.html">dgamevfs.exceptions</a></li>
<li><a href="dgamevfs.fs.html">dgamevfs.fs</a></li>
<li><a href="dgamevfs.stack.html">dgamevfs.stack</a></li>
<li><a href="dgamevfs.stream.html">dgamevfs.stream</a></li>
<li><a href="dgamevfs.vfs.html">dgamevfs.vfs</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>dgamevfs.vfs</h1>
<!-- Generated by Ddoc from dgamevfs/vfs.d -->
<br>
<dl><dt class="d_decl">abstract class <a name="VFSDir"></a><span class="ddoc_psymbol">VFSDir</span>;
</dt>
<dd><p>A directory in the VFS.
</p>
<p>Provides basic directory information and access to files and
 subdirectories within the directory.
<br>

 Directory names in the VFS can contain any characters except <b>/</b>,
 which is used as directory separator, and the <b>::</b> sequence, which is
 used for explicit package lookup (see  <span class="d_inlinecode">StackDir</span>).

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//Construct the directory (ordinary physical file system directory in this case):
</span> <span class="d_psymbol">VFSDir</span> dir = <span class="d_keyword">new</span> FSDir(<span class="d_string">"main"</span>, <span class="d_string">"./user_data/main"</span>, Yes.writable);

 <span class="d_comment">//Print information about the directory:
</span> writeln(<span class="d_string">"name: "</span>, dir.name,
         <span class="d_string">", full path: "</span>, dir.path,
         <span class="d_string">", writable: "</span>, dir.writable,
         <span class="d_string">", exists: "</span>, dir.exists);

 <span class="d_comment">//Access a file. If it does not exist, it will be created when writing:
</span> <span class="d_keyword">auto</span> file = dir.file(<span class="d_string">"logs/memory.log"</span>);

 <span class="d_comment">//Access a subdirectory:
</span> <span class="d_keyword">auto</span> shaders = dir.dir(<span class="d_string">"shaders"</span>);

 <span class="d_comment">//Create a subdirectory. If the directory exists, nothing happens (no error):
</span> <span class="d_keyword">auto</span> shaders = dir.dir(<span class="d_string">"does_not_exist"</span>).create();


 <span class="d_comment">//dirs() and files() methods can be used to get ranges of files and subdirectories:
</span>
 <span class="d_comment">//Print paths of all immediate subdirectories and their files:
</span> <span class="d_keyword">foreach</span>(subdir; dir.dirs())
 {
     writeln(dir.path, <span class="d_string">":"</span>);
     <span class="d_keyword">foreach</span>(file; subdir.files())
     {
         writeln(<span class="d_string">"    "</span>, file.path);
     }
 }

 <span class="d_comment">//Print paths of all subdirectories and their subdirectories, etc. recursively:
</span> <span class="d_keyword">foreach</span>(subdir; dir.dirs(Yes.deep))
 {
     writeln(dir.path);
 }

 <span class="d_comment">//Glob patterns can be used to filter the results:
</span>
 <span class="d_comment">//Print paths of all immediate subdirectories with paths containg "doc":
</span> <span class="d_keyword">foreach</span>(subdir; dir.dirs(No.deep, <span class="d_string">"*doc*"</span>))
 {
     writeln(dir.path);
 }

 <span class="d_comment">//Print paths of all files in the directory and in subdirectories with paths ending with ".txt":
</span> <span class="d_keyword">foreach</span>(file; dir.files(Yes.deep, <span class="d_string">"*.txt"</span>))
 {
     writeln(file.path);
 }
</pre>
</div>

<dl><dt class="d_decl">final const pure @property string <a name="name"></a><span class="ddoc_psymbol">name</span>();
</dt>
<dd><p>Get the name of this directory.</p>

</dd>
<dt class="d_decl">final const @property string <a name="path"></a><span class="ddoc_psymbol">path</span>();
</dt>
<dd><p>Get full path of this directory in the VFS.</p>

</dd>
<dt class="d_decl">const @property bool <a name="writable"></a><span class="ddoc_psymbol">writable</span>();
</dt>
<dd><p>Is it possible to write to the directory?</p>

</dd>
<dt class="d_decl">const @property bool <a name="exists"></a><span class="ddoc_psymbol">exists</span>();
</dt>
<dd><p>Does the directory exist?</p>

</dd>
<dt class="d_decl">VFSFile <a name="file"></a><span class="ddoc_psymbol">file</span>(string <b>path</b>);
</dt>
<dd><p>Get file with specified path in the directory.
</p>
<p>The file will be returned even if it does not exist -
 it will be created when writing into it.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>string <b>path</b></td>
<td valign=top>Path of the file to get.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSNotFoundException</span> if the directory does not exist
          or the file is in a nonexistent subdirectory.
<br>

          <span class="d_inlinecode">VFSInvalidPathException</span> if the path is invalid.

</div>
<b>Returns:</b><div class="pbr">File with specified path.</div>

</dd>
<dt class="d_decl">VFSDir <a name="dir"></a><span class="ddoc_psymbol">dir</span>(string <b>path</b>);
</dt>
<dd><p>Get a subdirectory with specified path in the directory.
</p>
<p>The subdirectory will be returned even if it does not exist -
 it can be created with the <span class="d_inlinecode">create()</span> method.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>string <b>path</b></td>
<td valign=top>Path of the subdirectory to get.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSNotFoundException</span> if this VFSDir does not exist
          or the subdirectory is in a nonexistent subdirectory.
<br>

          <span class="d_inlinecode">VFSInvalidPathException</span> if the path is invalid.

</div>
<b>Returns:</b><div class="pbr">Subdirectory with specified path.</div>

</dd>
<dt class="d_decl">VFSFiles <a name="files"></a><span class="ddoc_psymbol">files</span>(Flag!("<b>deep</b>") <b>deep</b> = (No).<b>deep</b>, string <b>glob</b> = null);
</dt>
<dd><p>Get a range of files in the directory.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>Flag!("<b>deep</b>") <b>deep</b></td>
<td valign=top>If <b>true</b>, recursively get files in subdirectories.
                 Otherwise only get files directly in this directory.</td></tr>
<tr><td valign=top>string <b>glob</b></td>
<td valign=top>Glob pattern used to filter the results.
                 If <b>null</b> (default), all files will be returned.
                 Otherwise only files whose VFS paths within this
                 directory match <b>glob</b> (case sensitive) will be
                 returned. Some characters of glob patterns
                 have special meanings: For instance, <i>*.txt</i>
                 matches any path ending with the <b>.txt</b> extension.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Range of the files.

</div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSNotFoundException</span> if the directory does not exist.

</div>
<b>See Also:</b><div class="pbr"><a href="http://en.wikipedia.org/wiki/Glob_%28programming%29">Wikipedia: glob (programming)</a></div>

</dd>
<dt class="d_decl">VFSDirs <a name="dirs"></a><span class="ddoc_psymbol">dirs</span>(Flag!("<b>deep</b>") <b>deep</b> = (No).<b>deep</b>, string <b>glob</b> = null);
</dt>
<dd><p>Get a range of subdirectories.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>Flag!("<b>deep</b>") <b>deep</b></td>
<td valign=top>If <b>true</b>, recursively get all subdirectories.
                 Otherwise just get subdirectories of this directory.</td></tr>
<tr><td valign=top>string <b>glob</b></td>
<td valign=top>Glob pattern used to filter the results.
                 If <b>null</b> (default), all subdirectories will be
                 returned. Otherwise only subdirectories whose VFS
                 paths within this directory match <b>glob</b>
                 (case sensitive) will be returned. Some characters of
                 glob patterns have special meanings: For instance,
                 <i>*.txt</i> matches any path ending with the <b>.txt</b>
                 extension.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Range of the directories.

</div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSNotFoundException</span> if the directory does not exist.</div>

</dd>
<dt class="d_decl">final void <a name="create"></a><span class="ddoc_psymbol">create</span>();
</dt>
<dd><p>Create the directory if it does not exist (otherwise do nothing).
</p>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if the directory could not be created.</div>

</dd>
<dt class="d_decl">void <a name="remove"></a><span class="ddoc_psymbol">remove</span>();
</dt>
<dd><p>Remove the directory if it exists (otherwise do nothing).
</p>
<p>Removes recursively, together with any subdirectories and files.

</p>
<p><b>Warning:</b><br>
This will make any references to subdirectories or
          files in this directory invalid.

</p>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if the directory could not be removed.</div>

</dd>
<dt class="d_decl">protected  this(VFSDir <b>parent</b>, string <b>pathInParent</b>);
</dt>
<dd><p>Constructor to initialize state common for <span class="d_inlinecode">VFSDir</span> implementations.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>VFSDir <b>parent</b></td>
<td valign=top>Parent directory. If <b>null</b>, this directory has no parent.</td></tr>
<tr><td valign=top>string <b>pathInParent</b></td>
<td valign=top>Path of the directory within the parent.</td></tr>
</table></div>

</dd>
<dt class="d_decl">protected static VFSDirs <a name="dirsRange"></a><span class="ddoc_psymbol">dirsRange</span>(VFSDirs.Items <b>dirs</b>);
</dt>
<dd><p>Construct a range from a set of directories.</p>

</dd>
<dt class="d_decl">protected static VFSFiles <a name="filesRange"></a><span class="ddoc_psymbol">filesRange</span>(VFSFiles.Items <b>files</b>);
</dt>
<dd><p>Construct a range from a set of files.</p>

</dd>
<dt class="d_decl">protected const string <a name="composePath"></a><span class="ddoc_psymbol">composePath</span>(const VFSDir <b>child</b>);
</dt>
<dd><p>Compose path for a child directory. Used e.g. to allow <span class="d_inlinecode">StackDir</span> to set children's paths.</p>

</dd>
<dt class="d_decl">protected void <a name="create_"></a><span class="ddoc_psymbol">create_</span>();
</dt>
<dd><p>Implementation of <span class="d_inlinecode">create()</span>. Caller contract guarantees that the directory is writable.</p>

</dd>
<dt class="d_decl">protected VFSDir <a name="copyWithoutParent"></a><span class="ddoc_psymbol">copyWithoutParent</span>();
</dt>
<dd><p>Return a copy of this VFSDir without a parent. Used for mounting.</p>

</dd>
<dt class="d_decl">protected final VFSDir <a name="getCopyWithoutParent"></a><span class="ddoc_psymbol">getCopyWithoutParent</span>(VFSDir <b>dir</b>);
</dt>
<dd><p>Access for derived classes to call copyWithoutParent() of other instances.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="VFSRange"></a><span class="ddoc_psymbol">VFSRange</span>(T) if (is(T == VFSDir) || is(T == VFSFile));
</dt>
<dd><p>A bidirectional range of VFS items (files or directories).
</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> <span class="d_comment">//VFSDirs is a VFSRange of directories - VFSFiles of files.
</span> VFSDirs dirs;

 <span class="d_comment">//Get the first directory.
</span> <span class="d_keyword">auto</span> f = dirs.front;

 <span class="d_comment">//Get the last directory.
</span> <span class="d_keyword">auto</span> b = dirs.back;

 <span class="d_comment">//Remove the first directory from the range (this will not remove the directory itself).
</span> dirs.popFront();

 <span class="d_comment">//Remove the last directory from the range (this will not remove the directory itself).
</span> dirs.popBack();

 <span class="d_comment">//Are there no files/directories ?
</span> <span class="d_keyword">bool</span> empty = r.empty;
</pre>
</div>

<dl><dt class="d_decl">bool <a name="compare"></a><span class="ddoc_psymbol">compare</span>(T <b>a</b>, T <b>b</b>);
</dt>
<dd><p>Function used to compare items alphabetically.</p>

</dd>
<dt class="d_decl">alias <a name="Items"></a><span class="ddoc_psymbol">Items</span>;
</dt>
<dd><p>Type used to store the items.</p>

</dd>
<dt class="d_decl">const pure size_t <a name="length"></a><span class="ddoc_psymbol">length</span>();
</dt>
<dd><p>Get number of items in the range.</p>

</dd>
<dt class="d_decl">void <a name="popFront"></a><span class="ddoc_psymbol">popFront</span>();
</dt>
<dd><p>Pop the front element from the range.</p>

</dd>
<dt class="d_decl">void <a name="popBack"></a><span class="ddoc_psymbol">popBack</span>();
</dt>
<dd><p>Pop the back element from the range.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">alias <a name="VFSDirs"></a><span class="ddoc_psymbol">VFSDirs</span>;
</dt>
<dd><p>A VFSRange of directories.</p>

</dd>
<dt class="d_decl">alias <a name="VFSFiles"></a><span class="ddoc_psymbol">VFSFiles</span>;
</dt>
<dd><p>A VFSRange of files.</p>

</dd>
<dt class="d_decl">abstract class <a name="VFSFile"></a><span class="ddoc_psymbol">VFSFile</span>;
</dt>
<dd><p>A file in the VFS.
</p>
<p>Provides basic file information and access to I/O.
<br>

 File names in the VFS can contain any characters except <b>/</b>,
 which is used as directory separator, and the <b>::</b> sequence, which is
 used for explicit package lookup (see  <span class="d_inlinecode">StackDir</span>).

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> VFSDir dir = <span class="d_keyword">new</span> FSDir(<span class="d_string">"main"</span>, <span class="d_string">"./user_data/main"</span>, Yes.writable);

 <span class="d_comment">//Get the file from a directory.
</span> <span class="d_psymbol">VFSFile</span> file = dir.file(<span class="d_string">"logs/memory.log"</span>);

 <span class="d_comment">//Print information about the file (note that we can only get file size of an existing file):
</span> writeln(<span class="d_string">"name: "</span>, file.name, <span class="d_string">", full path: "</span>, file.path,
         <span class="d_string">", writable: "</span>, file.writable, <span class="d_string">", exists: "</span>, file.exists,
         <span class="d_string">", size in bytes: "</span>, file.bytes);

 <span class="d_comment">//Get access to read from the file:
</span> <span class="d_keyword">auto</span> input = file.input;

 <span class="d_comment">//Simply read the file to a buffer:
</span> <span class="d_keyword">auto</span> buffer = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[file.bytes];
 file.input.read(buffer);

 <span class="d_comment">//Get access to write to the file:
</span> <span class="d_keyword">auto</span> output = file.output;

 <span class="d_comment">//Simply write a buffer to the file:
</span> file.output.write(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">void</span>[])<span class="d_string">"The answer is 42"</span>);
</pre>
</div>

<dl><dt class="d_decl">enum <a name="Mode"></a><span class="ddoc_psymbol">Mode</span>;
</dt>
<dd><p>File mode (used by implementations);</p>

</dd>
<dt class="d_decl">final const @property string <a name="name"></a><span class="ddoc_psymbol">name</span>();
</dt>
<dd><p>Get name of the file.</p>

</dd>
<dt class="d_decl">final const @property string <a name="path"></a><span class="ddoc_psymbol">path</span>();
</dt>
<dd><p>Get full path of the file in the VFS.</p>

</dd>
<dt class="d_decl">const @property ulong <a name="bytes"></a><span class="ddoc_psymbol">bytes</span>();
</dt>
<dd><p>Get file size in bytes.
</p>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSNotFoundException</span> if the file does not exist.</div>

</dd>
<dt class="d_decl">const @property bool <a name="exists"></a><span class="ddoc_psymbol">exists</span>();
</dt>
<dd><p>Does the file exist?</p>

</dd>
<dt class="d_decl">final const @property bool <a name="writable"></a><span class="ddoc_psymbol">writable</span>();
</dt>
<dd><p>Is it possible to write to this file?</p>

</dd>
<dt class="d_decl">const @property bool <a name="open"></a><span class="ddoc_psymbol">open</span>();
</dt>
<dd><p>Is the file open?</p>

</dd>
<dt class="d_decl">final @property VFSFileInput <a name="input"></a><span class="ddoc_psymbol">input</span>();
</dt>
<dd><p>Open the file and get reading access.
</p>
<b>Returns:</b><div class="pbr"><span class="d_inlinecode">VFSFileInput</span> providing input access to the file.

</div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if the file does not exist or is already open.</div>

</dd>
<dt class="d_decl">final @property VFSFileOutput <a name="output"></a><span class="ddoc_psymbol">output</span>(Flag!("<b>append</b>") <b>append</b> = (No).<b>append</b>);
</dt>
<dd><p>Open the file and get writing access. Must not already be open.
</p>
<b>Returns:</b><div class="pbr"><span class="d_inlinecode">VFSFileOutput</span> providing output access to the file.

</div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if the file is not writable or is already open.</div>

</dd>
<dt class="d_decl">protected  this(VFSDir <b>parent</b>, string <b>pathInParent</b>);
</dt>
<dd><p>Constructor to initialize state common for <span class="d_inlinecode">VFSFile</span> implementations.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>VFSDir <b>parent</b></td>
<td valign=top>Parent directory. Must not be <b>null</b>.</td></tr>
<tr><td valign=top>string <b>pathInParent</b></td>
<td valign=top>Path of the file within the parent.</td></tr>
</table></div>

</dd>
<dt class="d_decl">protected void <a name="openRead"></a><span class="ddoc_psymbol">openRead</span>();
</dt>
<dd><p>Open the file for reading.</p>

</dd>
<dt class="d_decl">protected void <a name="openWrite"></a><span class="ddoc_psymbol">openWrite</span>(Flag!("<b>append</b>") <b>append</b>);
</dt>
<dd><p>Open the file for writing/appending.</p>

</dd>
<dt class="d_decl">protected void[] <a name="read"></a><span class="ddoc_psymbol">read</span>(void[] <b>target</b>);
</dt>
<dd><p>Read up to <span class="d_inlinecode"><b>target</b>.length</span> bytes to <b>target</b> from current file position.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>void[] <b>target</b></td>
<td valign=top>Buffer to read to.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Slice of target containing the <a name="read"></a><span class="ddoc_psymbol">read</span> data.</div>

</dd>
<dt class="d_decl">protected void <a name="write"></a><span class="ddoc_psymbol">write</span>(in void[] <b>data</b>);
</dt>
<dd><p>Write <span class="d_inlinecode"><b>data</b>.length</span> bytes to file from current file position.</p>

</dd>
<dt class="d_decl">protected void <a name="seek"></a><span class="ddoc_psymbol">seek</span>(long <b>offset</b>, Seek <b>origin</b>);
</dt>
<dd><p>Seek <b>offset</b> bytes from <b>origin</b> within the file.</p>

</dd>
<dt class="d_decl">protected void <a name="close"></a><span class="ddoc_psymbol">close</span>();
</dt>
<dd><p>Close the file, finalizing any file operations.</p>

</dd>
<dt class="d_decl">protected static void <a name="openReadProxy"></a><span class="ddoc_psymbol">openReadProxy</span>(VFSFile <b>file</b>);
<br>protected static void <a name="openWriteProxy"></a><span class="ddoc_psymbol">openWriteProxy</span>(VFSFile <b>file</b>, Flag!("<b>append</b>") <b>append</b>);
<br>protected static void[] <a name="readProxy"></a><span class="ddoc_psymbol">readProxy</span>(VFSFile <b>file</b>, void[] <b>target</b>);
<br>protected static void <a name="writeProxy"></a><span class="ddoc_psymbol">writeProxy</span>(VFSFile <b>file</b>, in void[] <b>data</b>);
<br>protected static void <a name="seekProxy"></a><span class="ddoc_psymbol">seekProxy</span>(VFSFile <b>file</b>, long <b>offset</b>, Seek <b>origin</b>);
<br>protected static void <a name="closeProxy"></a><span class="ddoc_psymbol">closeProxy</span>(VFSFile <b>file</b>);
</dt>
<dd><p>Proxies to for derived VFSFiles to call protected members of other VFSFiles.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">enum <a name="Seek"></a><span class="ddoc_psymbol">Seek</span>;
</dt>
<dd><p>File seeking positions.</p>

<dl><dt class="d_decl"><a name="Set"></a><span class="ddoc_psymbol">Set</span></dt>
<dd><p>Beginning of file.</p>

</dd>
<dt class="d_decl"><a name="Current"></a><span class="ddoc_psymbol">Current</span></dt>
<dd><p>Current file position.</p>

</dd>
<dt class="d_decl"><a name="End"></a><span class="ddoc_psymbol">End</span></dt>
<dd><p>End of file.</p>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="VFSFileInput"></a><span class="ddoc_psymbol">VFSFileInput</span>;
</dt>
<dd><p>Provides basic file input functionality - seeking and reading.
</p>
<p><span class="d_inlinecode"><a name="VFSFileInput"></a><span class="ddoc_psymbol">VFSFileInput</span></span> uses reference counting so that the file is closed
 when the last instance of <span class="d_inlinecode"><a name="VFSFileInput"></a><span class="ddoc_psymbol">VFSFileInput</span></span> provided by the file is destroyed.

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> VFSFile file; <span class="d_comment">//initialized somewhere before
</span>
 <span class="d_keyword">auto</span> input = file.input;
 <span class="d_keyword">with</span>(input)
 {
     <span class="d_keyword">auto</span> buffer = <span class="d_keyword">new</span> <span class="d_keyword">ubyte</span>[32];

     <span class="d_comment">//Read the first 32 bytes from the file:
</span>     read(buffer);

     <span class="d_comment">//Read the next 32 bytes:
</span>     read(buffer);

     <span class="d_comment">//Read the last 32 bytes in the file:
</span>     seek(-32, file);
     read(buffer);
 }
</pre>
</div>

<dl><dt class="d_decl">void[] <a name="read"></a><span class="ddoc_psymbol">read</span>(void[] <b>target</b>);
</dt>
<dd><p>Read at most <span class="d_inlinecode"><b>target</b>.length</span> bytes starting at current file position to <b>target</b>.
</p>
<p>If the file does not have enough bytes to fill <b>target</b> or a reading
 error is encountered, it reads as much data as possible and returns
 the part of <b>target</b> containing the read data.

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>void[] <b>target</b></td>
<td valign=top>Buffer to read to.</td></tr>
</table></div>
<b>Returns:</b><div class="pbr">Number of bytes read.</div>

</dd>
<dt class="d_decl">void <a name="seek"></a><span class="ddoc_psymbol">seek</span>(long <b>offset</b>, Seek <b>origin</b>);
</dt>
<dd><p>Set file position to <b>offset</b> bytes from specified <b>origin</b>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>long <b>offset</b></td>
<td valign=top>Number of bytes to set file position relative to <b>origin</b>.</td></tr>
<tr><td valign=top>Seek <b>origin</b></td>
<td valign=top>Position to which <b>offset</b> is added.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if trying to seek before the beginning or beyond
          the end of file.</div>

</dd>
</dl>
</dd>
<dt class="d_decl">struct <a name="VFSFileOutput"></a><span class="ddoc_psymbol">VFSFileOutput</span>;
</dt>
<dd><p>Provides basic file output functionality - seeking and writing.
</p>
<p><span class="d_inlinecode"><a name="VFSFileOutput"></a><span class="ddoc_psymbol">VFSFileOutput</span></span> uses reference counting so that the file is closed
 when the last instance of <span class="d_inlinecode"><a name="VFSFileOutput"></a><span class="ddoc_psymbol">VFSFileOutput</span></span> provided by the file is destroyed.

</p>
<b>Examples:</b><div class="pbr"><pre class="d_code"> VFSFile file; <span class="d_comment">//initialized somewhere before
</span>
 <span class="d_keyword">auto</span> output = file.output;
 <span class="d_keyword">with</span>(output)
 {
     <span class="d_comment">//Write to the file:
</span>     write(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">void</span>[])<span class="d_string">"The answer is ??"</span>);

     <span class="d_comment">//Change the last two characters in the file:
</span>     seek(-2, Seek.End);
     write(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">void</span>[])<span class="d_string">"42"</span>);
 }
</pre>

<pre class="d_code"> <span class="d_comment">//Appending:
</span> <span class="d_comment">//When appending to the file, every write writes to the end of file
</span> <span class="d_comment">//regardless of any calls to seek(), and sets the file position
</span> <span class="d_comment">//to end of file. This
</span> <span class="d_comment">//(This is to stay in line with the C standard so we can use C functions directly)
</span> <span class="d_keyword">auto</span> output = file.output(Yes.append);
 <span class="d_keyword">with</span>(output)
 {
     <span class="d_comment">//Append to the file:
</span>     write(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">void</span>[])<span class="d_string">"The answer is ??"</span>);

     <span class="d_comment">//This will NOT change the last 2 characters: it will append anyway:
</span>     seek(-2, Seek.End);
     write(<span class="d_keyword">cast</span>(<span class="d_keyword">const</span> <span class="d_keyword">void</span>[])<span class="d_string">"42"</span>);
 }
</pre>
</div>

<dl><dt class="d_decl">void <a name="write"></a><span class="ddoc_psymbol">write</span>(in void[] <b>data</b>);
</dt>
<dd><p>Write <b>data</b> to file starting at current file position.
</p>
<p><b>Note:</b><br>
In append mode, any write will write to the end of file regardless
 of the current file position and file position will be set to the
 end of file.
<br>

 (This is to stay in line with the C standard so we can use C I/O functions directly)

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>void[] <b>data</b></td>
<td valign=top>Data to write to the file.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> on error (e.g. after running out of disk space).</div>

</dd>
<dt class="d_decl">void <a name="seek"></a><span class="ddoc_psymbol">seek</span>(long <b>offset</b>, Seek <b>origin</b>);
</dt>
<dd><p>Set file position to <b>offset</b> bytes from specified <b>origin</b>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>long <b>offset</b></td>
<td valign=top>Number of bytes to set file position relative to <b>origin</b>.</td></tr>
<tr><td valign=top>Seek <b>origin</b></td>
<td valign=top>Position to which <b>offset</b> is added.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSIOException</span> if trying to seek before the beginning or behind
          the end of file, or on a different error.</div>

</dd>
</dl>
</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2011 - 2012. |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
