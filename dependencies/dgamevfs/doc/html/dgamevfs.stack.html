<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"
        "http://www.w3.org/TR/html4/strict.dtd">

<html lang='en'>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" >
<title>dgamevfs.stack - D:GameVFS 0.1 API documentation</title>
<link rel="stylesheet" type="text/css" href="css/style.css">
</head>

<body><div id="top">
<div id="header">
<a id="main-heading" href="index.html">D:GameVFS 0.1 API documentation</a>
</div>
</div>

<div id="navigation">
<div class="navblock">
<div id="toctop">
<ul></ul>
</div>
</div>
<div class="navblock">
<ul><li><a href="index.html">Main page</a></li>
<li><a href="dgamevfs.exceptions.html">dgamevfs.exceptions</a></li>
<li><a href="dgamevfs.fs.html">dgamevfs.fs</a></li>
<li><a href="dgamevfs.stack.html">dgamevfs.stack</a></li>
<li><a href="dgamevfs.stream.html">dgamevfs.stream</a></li>
<li><a href="dgamevfs.vfs.html">dgamevfs.vfs</a></li>
</ul>
</div>
</div>

<div id="content">
<h1>dgamevfs.stack</h1>
<!-- Generated by Ddoc from dgamevfs/stack.d -->
<p>Stacked files/directories for seamless access to multiple directories as if they were a single directory.</p>

<dl><dt class="d_decl">class <a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span>: dgamevfs.vfs.VFSDir;
</dt>
<dd><p>A directory seamlessly working on a stack of multiple directories.
</p>
<p>Directories can be mounted using the <span class="d_inlinecode">mount()</span> method.
<br>

 When looking for a file or directory in a <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span>, the last directory
 is searched first, then the second last, and so on. This means that directories
 mounted later override those mounted before.

</p>
<p><b>Example:</b><br>
We have a directory called <i>data</i> with the following contents:
<pre class="d_code"> shaders:
     font.frag
     font.vert
 logs:
     (empty)
 main.cfg
</pre>
 and a directory called <i>user_data</i> with the following contents:
<pre class="d_code"> shaders:
      font.frag
 logs:
      (empty)
 custom.cfg
</pre>
 the following code will work as specified in the comments:
<pre class="d_code"> VFSDir data, user_data; <span class="d_comment">//initialized somewhere before
</span>
 <span class="d_keyword">auto</span> stack = <span class="d_keyword">new</span> <span class="d_psymbol">StackDir</span>(<span class="d_string">"stack"</span>);
 stack.mount(data);
 stack.mount(user_data);

 <span class="d_comment">//This will access user_data/shaders/font.frag
</span> <span class="d_keyword">auto</span> frag = stack.file(<span class="d_string">"shaders/font.frag"</span>);
 <span class="d_comment">//This will access data/shaders/font.vert
</span> <span class="d_keyword">auto</span> vert = stack.file(<span class="d_string">"shaders/font.vert"</span>);
 <span class="d_comment">//This will return a StackDir (as VFSDir) with "data/logs" and "user_data/logs"
</span> <span class="d_comment">//mounted, in that order:
</span> <span class="d_keyword">auto</span> logs = stack.dir(<span class="d_string">"logs"</span>);
</pre>

 Accessing a file in a <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span> will actually return a <span class="d_inlinecode">StackFile</span>,
 which decides which file to access on read, write and other operations.
 The <span class="d_inlinecode">StackFile</span> is a stack of all files that map to the same path in
 the <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span> in the same order as <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span>'s mounted directories.
<br>

 For example, when reading or determining file size, the directories in the
 stack will be searched from newest to oldest and the first file found will
 be used.
<br>

 When writing, the file in the newest writable directory will be written to.
<br>

<br>

 In some cases, it might be required to access a particular directory in the
 stack. E.g. a game might have multiple packages stacked on top of each other,
 but sometimes default, non-overridden version of a file could be needed.
 This can be done using the <b>::</b> separator.
<br>

 In the context of the previous example:
<br>

<pre class="d_code"> <span class="d_comment">//This will access data/shaders/font.frag even though user_data/shaders/font.frag exists
</span> <span class="d_keyword">auto</span> default_frag = stack.file(<span class="d_string">"data::shaders/font.frag"</span>);
</pre>

 <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span> is considered writable when any directory in the stack is writable.
 Similarly, it exists when any directory in the stack exists.
<br>

 When we have a <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span> that does not exist and we <span class="d_inlinecode">create()</span> it,
 the newest directory that is writable will be created.
 (This can happen when getting a nonexistent subdirectory of a <span class="d_inlinecode"><a name="StackDir"></a><span class="ddoc_psymbol">StackDir</span></span>.)</p>

<dl><dt class="d_decl">this(string <b>name</b>);
</dt>
<dd><p>Construct a  <span class="d_inlinecode">StackDir</span>.
</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>string <b>name</b></td>
<td valign=top>Name of the  <span class="d_inlinecode">StackDir</span>.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSInvalidPathException</span> if <b>name</b> is not valid (contains '/' or "::").</div>

</dd>
<dt class="d_decl">void <a name="mount"></a><span class="ddoc_psymbol">mount</span>(VFSDir <b>dir</b>);
</dt>
<dd><p>Mount a directory.
</p>
<p>Files and directories of a directory mounted later will override
 those of a directory mounted earlier.
<br>

 If <b>dir</b> has a parent in the VFS, a parent-less copy will be created and
 mounted. (This has no effect whatsoever on the underlying filesystem -
 it just removes the need for directories to have multiple parents).

</p>
<b>Parameters:</b><div class="pbr"><table class=parms><tr><td valign=top>VFSDir <b>dir</b></td>
<td valign=top>Directory to mount.</td></tr>
</table></div>
<b>Throws:</b><div class="pbr"><span class="d_inlinecode">VFSMountException</span> if a directory with the same name is
          already mounted, or if <b>dir</b> has this directory as its child
          or a child of any of its subdirectories (circular mounting).</div>

</dd>
</dl>
</dd>
<dt class="d_decl">class <a name="StackFile"></a><span class="ddoc_psymbol">StackFile</span>: dgamevfs.vfs.VFSFile;
</dt>
<dd><p>A file seamlessly working on a stack of multiple files.
</p>
<p>This is the file implementation returned by  <span class="d_inlinecode">StackDir</span> methods.
<br>

 It has one file from each directory in the  <span class="d_inlinecode">StackDir</span> - all of these
 files map to the same path in the <span class="d_inlinecode">StackDir</span>.
<br>

 When reading from <span class="d_inlinecode"><a name="StackFile"></a><span class="ddoc_psymbol">StackFile</span></span>, it will read from the newest file
 in the stack that exists.
<br>

 When writing, it will write to the newest file that is writable
 regardless of whether it already exists or not.</p>

</dd>
</dl>

</div>

<div id="copyright">
Copyright &copy; Ferdinand Majerech 2011 - 2012. |
Page generated by AutoDDoc and <a href="http://www.digitalmars.com/d/2.0/ddoc.html">Ddoc</a>.
</div>

</body>
</html>
